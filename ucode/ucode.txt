# cpu2 microcode

# GP register device IDs, for rd_dev and wr_dev signals
def r0 0b0000;
def r2 0b0001;
def r4 0b0010;
def r6 0b0011;
def r1 0b0100;
def r3 0b0101;
def r5 0b0110;
def r7 0b0111;

# Other device IDs, for rd_dev and wr_dev signals
def arlo 0b1000;
def arhi 0b1001;
def pclo 0b1010;
def pchi 0b1011;
def mem 0b1100;

# Note: ALU operation codes are for the 74HC181 (see datasheet)
# In general, carry in should not be asserted except in special
# cases (such as subtraction)

# Logical ALU operation codes (ensure aluMode=1)
def alu_logic_A      0b1111; # copy A (left ALU bus) to ALU output
def alu_logic_B      0b1010; # copy B (right ALU bus) to ALU output
def alu_logic_and    0b1011; # bitwise AND
def alu_logic_or     0b1110; # bitwise OR
def alu_logic_xor    0b0110; # bitwise XOR

# Math ALU operation codes (ensure aluMode=0)
def alu_math_add     0b1001; # left+right
def alu_math_sub     0b0110; # left-right (carry in must be asserted)
def alu_math_lshift  0b1100; # shift left value left by one bit

# device being read
signal rd_dev[4] default 0b1111;

# device being written
signal wr_dev[4] default 0b1111;

# mark end of microcode operations
signal end[1] default 0;

# clock signal for incrementing program counter
# (the counters are always enabled, but we send a clock
# pulse only when we want to increment the PC)
signal pcClk[1] default 0;   # driven as inverted

# Drive ALU output to ALU data bus
signal aluOut[1] default 0;   # driven as inverted

# Carry in signal to ALU
signal aluCarryIn[1] default 0; # driven as inverted

# Mode signal to ALU
signal aluMode[1] default 0;

# Operation signal to ALU
signal aluOp[4] default 0b0000;

# Template for register/register move instructions
template mov(dest_dev, src_dev) {
  rd_dev=src_dev;
  wr_dev=dest_dev;
  wr_dev=default;
  rd_dev=default, end=1;
}

# nop instruction
ins(0) { end=1; }

# Move to r0
ins(1) { mov(r0, r1); }
ins(2) { mov(r0, r2); }
ins(3) { mov(r0, r3); }
ins(4) { mov(r0, r4); }
ins(5) { mov(r0, r5); }
ins(6) { mov(r0, r6); }
ins(7) { mov(r0, r7); }

# Move to r1
ins(8) { mov(r1, r0); }
ins(9) { mov(r1, r2); }
ins(10) { mov(r1, r3); }
ins(11) { mov(r1, r4); }
ins(12) { mov(r1, r5); }
ins(13) { mov(r1, r6); }
ins(14) { mov(r1, r7); }

# Move to r2
ins(15) { mov(r2, r0); }
ins(16) { mov(r2, r1); }
ins(17) { mov(r2, r3); }
ins(18) { mov(r2, r4); }
ins(19) { mov(r2, r5); }
ins(20) { mov(r2, r6); }
ins(21) { mov(r2, r7); }

# Move to r3
ins(22) { mov(r3, r0); }
ins(23) { mov(r3, r1); }
ins(24) { mov(r3, r2); }
ins(25) { mov(r3, r4); }
ins(26) { mov(r3, r5); }
ins(27) { mov(r3, r6); }
ins(28) { mov(r3, r7); }

# Move to r4
ins(29) { mov(r4, r0); }
ins(30) { mov(r4, r1); }
ins(31) { mov(r4, r2); }
ins(32) { mov(r4, r3); }
ins(33) { mov(r4, r5); }
ins(34) { mov(r4, r6); }
ins(35) { mov(r4, r7); }

# Move to r5
ins(36) { mov(r5, r0); }
ins(37) { mov(r5, r1); }
ins(38) { mov(r5, r2); }
ins(39) { mov(r5, r3); }
ins(40) { mov(r5, r4); }
ins(41) { mov(r5, r6); }
ins(42) { mov(r5, r7); }

# Move to r6
ins(43) { mov(r6, r0); }
ins(44) { mov(r6, r1); }
ins(45) { mov(r6, r2); }
ins(46) { mov(r6, r3); }
ins(47) { mov(r6, r4); }
ins(48) { mov(r6, r5); }
ins(49) { mov(r6, r7); }

# Move to r7
ins(50) { mov(r7, r0); }
ins(51) { mov(r7, r1); }
ins(52) { mov(r7, r2); }
ins(53) { mov(r7, r3); }
ins(54) { mov(r7, r4); }
ins(55) { mov(r7, r5); }
ins(56) { mov(r7, r6); }

# vim:ft=ucode:
