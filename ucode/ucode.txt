# cpu2 microcode

########################################################################
# Definitions (convenient symbolic names for bit patterns)
########################################################################

# GP register addresses (for rdGPAddr and wrGPAddr signals).
# Note that these don't uniquely identify a register: an
# ALU op must be selected for a read, and the wrGPLo or wrGPHi
# signal must be asserted for a write.
def r0_r1 0b00;
def r2_r3 0b01;
def r4_r5 0b10;
def r6_r7 0b11;

# Note: ALU operation codes are for the 74HC181 (see datasheet)
# In general, carry in should not be asserted except in special
# cases (such as subtraction)

# Logical ALU operation codes (ensure aluMode=1)
def alu_logic_A      0b1111; # copy A (left ALU bus) to ALU output
def alu_logic_B      0b1010; # copy B (right ALU bus) to ALU output
def alu_logic_and    0b1011; # bitwise AND
def alu_logic_or     0b1110; # bitwise OR
def alu_logic_xor    0b0110; # bitwise XOR
def alu_logic_complA 0b0000; # bitwise complement of A (left ALU bus)
def alu_logic_complB 0b0101; # bitwise complement of B (right ALU bus)

# Math ALU operation codes (ensure aluMode=0)
def alu_math_add     0b1001; # left+right
def alu_math_sub     0b0110; # left-right (carry in must be asserted)
def alu_math_lshift  0b1100; # shift left value left by one bit

########################################################################
# Signals
########################################################################

# Note about read/write signals: all are active low
# and thus driven as inverted, to make sure that the reset
# state is not asserted.

# ROM 1
signal rdGP[1] default 0;                # LSB
signal rdGPAddr[2] default 0b00;
signal rdAR[1] default 0;
signal rdPC[1] default 0;
signal rwMem[1] default 0;               # read or write memory, driven as inverted
signal wrGPLo[1] default 0;
signal wrGPHi[1] default 0;              # MSB

# ROM 2
signal wrGPAddr[2] default 0b00;         # LSB
signal wrARLo[1] default 0;
signal wrARHi[1] default 0;
signal wrPCLo[1] default 0;
signal wrPCHi[1] default 0;
signal memDir[1] default 0;              # 0=read external data, 1=write external data

# drive the left/right ALU input busses onto the external
# address busses
signal driveAddr[1] default 0;           # MSB, driven as inverted

# ROM 3

# Carry in signal to ALU
signal aluCarryIn[1] default 0;          # LSB, driven as inverted

# Mode signal to ALU
signal aluMode[1] default 0;

# Drive ALU output to ALU data bus
signal aluOut[1] default 0;              # driven as inverted

# PC increment clock signal
signal pcClk[1] default 0;               # driven as inverted

# Operation signal to ALU
signal aluOp[4] default 0b0000;          # high bit is MSB

# ROM 4

# Assert to end microcode execution if eq condition is asserted
signal -endIfEq[1] default 1;

# Assert to end microcode execution if eq condition is not asserted
signal -endIfNeq[1] default 1;

# Assert to end microcode execution if carry out condition is asserted
signal -endIfNoCarry[1] default 1;

# Assert to end microcode execution if eq condition is not asserted
# and carry out condition is asserted
signal endIfNeqCarry[1] default 0;

# Assert to end microcode execution if eq condition is not asserted
# and carry out condition is not asserted
signal endIfNeqNoCarry[1] default 0;

# Unconditionally end microcode execution.
# The last microcode word should always assert this signal.
signal -endUncond[1] default 1;

signal rom4Unused[2] default 0b00;

########################################################################
# Patterns: assertions of one or more signals.  These are
# very useful because they can be passed to a template.
########################################################################

# Read signal patterns (most of which require an ALU op)
# Note that for reads from GP registers, the address is asserted
# on the same clock that the read select starts.  So, incorrect
# data may be asserted initially (since the register pair read
# address is changing), but the correct data is guaranteed to be
# present by the next clock.
pattern rd_r0 rdGP=1, rdGPAddr=r0_r1, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_r1 rdGP=1, rdGPAddr=r0_r1, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_r2 rdGP=1, rdGPAddr=r2_r3, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_r3 rdGP=1, rdGPAddr=r2_r3, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_r4 rdGP=1, rdGPAddr=r4_r5, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_r5 rdGP=1, rdGPAddr=r4_r5, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_r6 rdGP=1, rdGPAddr=r6_r7, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_r7 rdGP=1, rdGPAddr=r6_r7, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_ar_lo rdAR=1, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_ar_hi rdAR=1, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_pc_lo rdPC=1, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_pc_hi rdPC=1, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_mem rwMem=1, memDir=0;

# Banks for GP register writes
pattern wr_gp_lo wrGPLo=1;
pattern wr_gp_hi wrGPHi=1;

########################################################################
# Templates: parametized instructions sequences that can
# be spliced into actual instructions as appropriate
########################################################################

# Template for register/register move instructions
template mov(dest_reg, wr_bank_pat, src_reg_pat) {
	# assert gp register write address, select source register data onto ALU bus
	wrGPAddr=dest_reg, start src_reg_pat;
	# begin write to destination register
	start wr_bank_pat;
	# end write to destination register
	stop wr_bank_pat;
	# end read from source register, end instruction
	stop src_reg_pat, assert -endUncond;
}

# Template for memory load into GP reg, address selected
# by gp register pair
template ld(dest_reg, wr_bank_pat, src_pair) {
	# Assert the gp register pair address, read GP register banks,
	# drive the left/right ALU busses onto the low/high address busses,
	# and assert the gp register pair address for the destination register.
	rdGPAddr=src_pair, assert rdGP, assert driveAddr, wrGPAddr=dest_reg;

	# Issue memory read signal
	start rd_mem;

	# Start dest register bank write signal
	# Possible optimization: could do this at same time as
	# read signal (since data isn't officially clocked
	# in until the write signal is deasserted, by which
	# time the data memory read data should be valid)
	start wr_bank_pat;

	# End dest register bank write signal: data should be clocked in
	# the destination register at this point
	stop wr_bank_pat;

	# End address generation and memory read, end instruction
	deassert rdGP, deassert driveAddr, stop rd_mem, assert -endUncond;
}

########################################################################
# Instructions
#
# Each instruction is a sequence of microcode instruction
# words executed in order.
########################################################################

# nop instruction
ins(0) { assert -endUncond; }

# GP reg move to r0
ins($) { mov(r0_r1, wr_gp_lo, rd_r1); }
ins($) { mov(r0_r1, wr_gp_lo, rd_r2); }
ins($) { mov(r0_r1, wr_gp_lo, rd_r3); }
ins($) { mov(r0_r1, wr_gp_lo, rd_r4); }
ins($) { mov(r0_r1, wr_gp_lo, rd_r5); }
ins($) { mov(r0_r1, wr_gp_lo, rd_r6); }
ins($) { mov(r0_r1, wr_gp_lo, rd_r7); }

# GP reg move to r1
ins($) { mov(r0_r1, wr_gp_hi, rd_r0); }
ins($) { mov(r0_r1, wr_gp_hi, rd_r2); }
ins($) { mov(r0_r1, wr_gp_hi, rd_r3); }
ins($) { mov(r0_r1, wr_gp_hi, rd_r4); }
ins($) { mov(r0_r1, wr_gp_hi, rd_r5); }
ins($) { mov(r0_r1, wr_gp_hi, rd_r6); }
ins($) { mov(r0_r1, wr_gp_hi, rd_r7); }

# GP reg move to r2
ins($) { mov(r2_r3, wr_gp_lo, rd_r0); }
ins($) { mov(r2_r3, wr_gp_lo, rd_r1); }
ins($) { mov(r2_r3, wr_gp_lo, rd_r3); }
ins($) { mov(r2_r3, wr_gp_lo, rd_r4); }
ins($) { mov(r2_r3, wr_gp_lo, rd_r5); }
ins($) { mov(r2_r3, wr_gp_lo, rd_r6); }
ins($) { mov(r2_r3, wr_gp_lo, rd_r7); }

# GP reg move to r3
ins($) { mov(r2_r3, wr_gp_hi, rd_r0); }
ins($) { mov(r2_r3, wr_gp_hi, rd_r1); }
ins($) { mov(r2_r3, wr_gp_hi, rd_r2); }
ins($) { mov(r2_r3, wr_gp_hi, rd_r4); }
ins($) { mov(r2_r3, wr_gp_hi, rd_r5); }
ins($) { mov(r2_r3, wr_gp_hi, rd_r6); }
ins($) { mov(r2_r3, wr_gp_hi, rd_r7); }

# GP reg move to r4
ins($) { mov(r4_r5, wr_gp_lo, rd_r0); }
ins($) { mov(r4_r5, wr_gp_lo, rd_r1); }
ins($) { mov(r4_r5, wr_gp_lo, rd_r2); }
ins($) { mov(r4_r5, wr_gp_lo, rd_r3); }
ins($) { mov(r4_r5, wr_gp_lo, rd_r5); }
ins($) { mov(r4_r5, wr_gp_lo, rd_r6); }
ins($) { mov(r4_r5, wr_gp_lo, rd_r7); }

# GP reg move to r5
ins($) { mov(r4_r5, wr_gp_hi, rd_r0); }
ins($) { mov(r4_r5, wr_gp_hi, rd_r1); }
ins($) { mov(r4_r5, wr_gp_hi, rd_r2); }
ins($) { mov(r4_r5, wr_gp_hi, rd_r3); }
ins($) { mov(r4_r5, wr_gp_hi, rd_r4); }
ins($) { mov(r4_r5, wr_gp_hi, rd_r6); }
ins($) { mov(r4_r5, wr_gp_hi, rd_r7); }

# GP reg move to r6
ins($) { mov(r6_r7, wr_gp_lo, rd_r0); }
ins($) { mov(r6_r7, wr_gp_lo, rd_r1); }
ins($) { mov(r6_r7, wr_gp_lo, rd_r2); }
ins($) { mov(r6_r7, wr_gp_lo, rd_r3); }
ins($) { mov(r6_r7, wr_gp_lo, rd_r4); }
ins($) { mov(r6_r7, wr_gp_lo, rd_r5); }
ins($) { mov(r6_r7, wr_gp_lo, rd_r7); }

# GP reg move to r7
ins($) { mov(r6_r7, wr_gp_hi, rd_r0); }
ins($) { mov(r6_r7, wr_gp_hi, rd_r1); }
ins($) { mov(r6_r7, wr_gp_hi, rd_r2); }
ins($) { mov(r6_r7, wr_gp_hi, rd_r3); }
ins($) { mov(r6_r7, wr_gp_hi, rd_r4); }
ins($) { mov(r6_r7, wr_gp_hi, rd_r5); }
ins($) { mov(r6_r7, wr_gp_hi, rd_r6); }

# Memory load to r0, address specified by GP reg pair
ins($) { ld(r0_r1, wr_gp_lo, r0_r1); }
ins($) { ld(r0_r1, wr_gp_lo, r2_r3); }
ins($) { ld(r0_r1, wr_gp_lo, r4_r5); }
ins($) { ld(r0_r1, wr_gp_lo, r6_r7); }

# Memory load to r1, address specified by GP reg pair
ins($) { ld(r0_r1, wr_gp_hi, r0_r1); }
ins($) { ld(r0_r1, wr_gp_hi, r2_r3); }
ins($) { ld(r0_r1, wr_gp_hi, r4_r5); }
ins($) { ld(r0_r1, wr_gp_hi, r6_r7); }

# Memory load to r2, address specified by GP reg pair
ins($) { ld(r2_r3, wr_gp_lo, r0_r1); }
ins($) { ld(r2_r3, wr_gp_lo, r2_r3); }
ins($) { ld(r2_r3, wr_gp_lo, r4_r5); }
ins($) { ld(r2_r3, wr_gp_lo, r6_r7); }

# Memory load to r3, address specified by GP reg pair
ins($) { ld(r2_r3, wr_gp_hi, r0_r1); }
ins($) { ld(r2_r3, wr_gp_hi, r2_r3); }
ins($) { ld(r2_r3, wr_gp_hi, r4_r5); }
ins($) { ld(r2_r3, wr_gp_hi, r6_r7); }

# Memory load to r4, address specified by GP reg pair
ins($) { ld(r4_r5, wr_gp_lo, r0_r1); }
ins($) { ld(r4_r5, wr_gp_lo, r2_r3); }
ins($) { ld(r4_r5, wr_gp_lo, r4_r5); }
ins($) { ld(r4_r5, wr_gp_lo, r6_r7); }

# Memory load to r5, address specified by GP reg pair
ins($) { ld(r4_r5, wr_gp_hi, r0_r1); }
ins($) { ld(r4_r5, wr_gp_hi, r2_r3); }
ins($) { ld(r4_r5, wr_gp_hi, r4_r5); }
ins($) { ld(r4_r5, wr_gp_hi, r6_r7); }

# Memory load to r6, address specified by GP reg pair
ins($) { ld(r6_r7, wr_gp_lo, r0_r1); }
ins($) { ld(r6_r7, wr_gp_lo, r2_r3); }
ins($) { ld(r6_r7, wr_gp_lo, r4_r5); }
ins($) { ld(r6_r7, wr_gp_lo, r6_r7); }

# Memory load to r7, address specified by GP reg pair
ins($) { ld(r6_r7, wr_gp_hi, r0_r1); }
ins($) { ld(r6_r7, wr_gp_hi, r2_r3); }
ins($) { ld(r6_r7, wr_gp_hi, r4_r5); }
ins($) { ld(r6_r7, wr_gp_hi, r6_r7); }

# special "default" instruction: this sequence of microcode
# instruction words is used for all opcodes that aren't explicitly
# specified
ins(256) { assert -endUncond; }

# vim:ft=ucode:
