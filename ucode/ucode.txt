# cpu2 microcode

########################################################################
# Definitions (convenient symbolic names for bit patterns)
########################################################################

# Device read IDs.
# For GP, AR, and PC, the low and high values
# are asserted onto the left and right ALU busses.
# For GP, the register pair (r0/r1, r2/r3, etc.)
# is selected with the two low bits.
# For the mem device, the value from the external
# data bus is asserted onto the ALU data bus.
def rd_id_gp_r0_r1  0b000;
def rd_id_gp_r2_r3  0b001;
def rd_id_gp_r4_r5  0b010;
def rd_id_gp_r6_r7  0b011;
def rd_id_ar        0b100;
def rd_id_pc        0b101;
def rd_id_mem       0b110;

# Device write IDs.
# Each ID selects a single device rather than a pair.

# GP register write ids
def wr_id_r0 0b0000;
def wr_id_r2 0b0001;
def wr_id_r4 0b0010;
def wr_id_r6 0b0011;
def wr_id_r1 0b0100;
def wr_id_r3 0b0101;
def wr_id_r5 0b0110;
def wr_id_r7 0b0111;

# Other device IDs for writing
def wr_id_arlo 0b1000;
def wr_id_arhi 0b1001;
def wr_id_pclo 0b1010;
def wr_id_pchi 0b1011;
def wr_id_mem 0b1100;

# Note: ALU operation codes are for the 74HC181 (see datasheet)
# In general, carry in should not be asserted except in special
# cases (such as subtraction)

# Logical ALU operation codes (ensure aluMode=1)
def alu_logic_A      0b1111; # copy A (left ALU bus) to ALU output
def alu_logic_B      0b1010; # copy B (right ALU bus) to ALU output
def alu_logic_and    0b1011; # bitwise AND
def alu_logic_or     0b1110; # bitwise OR
def alu_logic_xor    0b0110; # bitwise XOR
def alu_logic_complA 0b0000; # bitwise complement of A (left ALU bus)
def alu_logic_complB 0b0101; # bitwise complement of B (right ALU bus)

# Math ALU operation codes (ensure aluMode=0)
def alu_math_add     0b1001; # left+right
def alu_math_sub     0b0110; # left-right (carry in must be asserted)
def alu_math_lshift  0b1100; # shift left value left by one bit

########################################################################
# First microcode ROM: read/write device signals
#
# Reading from a device asserts the output from the
# low and high device pair (r0/r1, gplo/gphi, etc.)
# onto the left and right ALU input busses, except in
# the case of reading from memory, which is asserted
# directly onto the ALU data bus.
#
# Writing to a device signals that it should take its
# new contents from the ALU data bus.
########################################################################

# device being read: note that an ALU op is needed to
# select the ALU input bus (left or right) being read from
signal rdDev[3] default 0b111;

# device being written
signal wrDev[4] default 0b1111;

# one unused bit here, could use it for something
signal rwunused[1] default 0;

########################################################################
# Second microcode ROM: misc. control signals
########################################################################

# clock signal for incrementing program counter
# (the counters are always enabled, but we send a clock
# pulse only when we want to increment the PC)
signal pcClk[1] default 0;   # driven as inverted

# Assert the PC onto the left and right ALU busses,
signal pcGenAddr[1] default 0; # driven as inverted

# Assert the AR (address register) onto the left and
# right ALU busses
signal arGenAddr[1] default 0; # driven as inverted

# Assert the GP register pair indicated by the two low bits
# of the rdDev signal onto the left and right ALU busses
signal gpGenAddr[1] default 0; # driven as inverted

# Drive the left/right ALU busses onto the low/high address
# busses.
signal driveAddr[1] default 0; # driven as inverted

# 3 bits are still available: will need these
# for conditional control flow instructions.
signal unused[3] default 0b000;

########################################################################
# Third microcode ROM: ALU control, and the end signal to
# terminate microcode execution for the current instruction
########################################################################

# Carry in signal to ALU
signal aluCarryIn[1] default 0; # driven as inverted

# Mode signal to ALU
signal aluMode[1] default 0;

# Operation signal to ALU
signal aluOp[4] default 0b0000;

# Drive ALU output to ALU data bus
signal aluOut[1] default 0;   # driven as inverted

# mark end of microcode operations
signal end[1] default 0;

########################################################################
# Patterns: assertions of multiple signals simultaneously
########################################################################

# Read signal patterns (most of which require an ALU op)
pattern rd_r0 rdDev=rd_id_gp_r0_r1, aluOp=alu_logic_A;
pattern rd_r1 rdDev=rd_id_gp_r0_r1, aluOp=alu_logic_B;
pattern rd_r2 rdDev=rd_id_gp_r2_r3, aluOp=alu_logic_A;
pattern rd_r3 rdDev=rd_id_gp_r2_r3, aluOp=alu_logic_B;
pattern rd_r4 rdDev=rd_id_gp_r4_r5, aluOp=alu_logic_A;
pattern rd_r5 rdDev=rd_id_gp_r4_r5, aluOp=alu_logic_B;
pattern rd_r6 rdDev=rd_id_gp_r6_r7, aluOp=alu_logic_A;
pattern rd_r7 rdDev=rd_id_gp_r6_r7, aluOp=alu_logic_B;
pattern rd_ar_lo rdDev=rd_id_ar, aluOp=alu_logic_A;
pattern rd_ar_hi rdDev=rd_id_ar, aluOp=alu_logic_B;
pattern rd_pc_lo rdDev=rd_id_pc, aluOp=alu_logic_A;
pattern rd_pc_hi rdDev=rd_id_pc, aluOp=alu_logic_B;
pattern rd_mem rdDev=rd_id_mem;

# Write signal patterns
pattern wr_r0 wrDev=wr_id_r0;
pattern wr_r1 wrDev=wr_id_r1;
pattern wr_r2 wrDev=wr_id_r2;
pattern wr_r3 wrDev=wr_id_r3;
pattern wr_r4 wrDev=wr_id_r4;
pattern wr_r5 wrDev=wr_id_r5;
pattern wr_r6 wrDev=wr_id_r6;
pattern wr_r7 wrDev=wr_id_r7;

########################################################################
# Templates: parametized instructions sequences that can
# be spliced into actual instructions as appropriate
########################################################################

# Template for register/register move instructions
template mov(dest_dev, src_dev) {
  start src_dev;
  start dest_dev;
  stop dest_dev;
  stop src_dev;
}

########################################################################
# Instructions
#
# Each instruction is a sequence of microcode instruction
# words executed in order.
########################################################################

# nop instruction
ins(0) { end=1; }

# Move to r0
ins(1) { mov(wr_r0, rd_r1); }
ins(1) { mov(wr_r0, rd_r2); }
ins(1) { mov(wr_r0, rd_r3); }
ins(1) { mov(wr_r0, rd_r4); }
ins(1) { mov(wr_r0, rd_r5); }
ins(1) { mov(wr_r0, rd_r6); }
ins(1) { mov(wr_r0, rd_r7); }

# vim:ft=ucode:
