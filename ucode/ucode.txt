# cpu2 microcode

########################################################################
# Definitions (convenient symbolic names for bit patterns)
########################################################################

# GP register addresses (for rdGPAddr and wrGPAddr signals).
# Note that these don't uniquely identify a register: an
# ALU op must be selected for a read, and the wrGPLo or wrGPHi
# signal must be asserted for a write.
def r0 0b00;
def r1 0b00;
def r2 0b01;
def r3 0b01;
def r4 0b10;
def r5 0b10;
def r6 0b11;
def r7 0b11;

# Note: ALU operation codes are for the 74HC181 (see datasheet)
# In general, carry in should not be asserted except in special
# cases (such as subtraction)

# Logical ALU operation codes (ensure aluMode=1)
def alu_logic_A      0b1111; # copy A (left ALU bus) to ALU output
def alu_logic_B      0b1010; # copy B (right ALU bus) to ALU output
def alu_logic_and    0b1011; # bitwise AND
def alu_logic_or     0b1110; # bitwise OR
def alu_logic_xor    0b0110; # bitwise XOR
def alu_logic_complA 0b0000; # bitwise complement of A (left ALU bus)
def alu_logic_complB 0b0101; # bitwise complement of B (right ALU bus)

# Math ALU operation codes (ensure aluMode=0)
def alu_math_add     0b1001; # left+right
def alu_math_sub     0b0110; # left-right (carry in must be asserted)
def alu_math_lshift  0b1100; # shift left value left by one bit

########################################################################
# Signals
########################################################################

# Note about read/write signals: all are active low
# and thus driven as inverted, to make sure that the reset
# state is not asserted.

# ROM 1
signal rdGP[1] default 0;                # LSB
signal rdGPAddr[2] default 0b00;
signal rdAR[1] default 0;
signal rdPC[1] default 0;
signal rwMem[1] default 0;               # read or write memory, driven as inverted
signal wrGPLo[1] default 0;
signal wrGPHi[1] default 0;              # MSB

# ROM 2
signal wrGPAddr[2] default 0b00;         # LSB
signal wrARLo[1] default 0;
signal wrARHi[1] default 0;
signal wrPCLo[1] default 0;
signal wrPCHi[1] default 0;
signal memDir[1] default 0;              # 0=read external data, 1=write external data

# drive the left/right ALU input busses onto the external
# address busses
signal driveAddr[1] default 0;           # MSB, driven as inverted

# ROM 3

# Carry in signal to ALU
signal aluCarryIn[1] default 0;          # LSB, driven as inverted

# Mode signal to ALU
signal aluMode[1] default 0;

# Drive ALU output to ALU data bus
signal aluOut[1] default 0;              # driven as inverted

# PC increment clock signal
signal pcClk[1] default 0;               # driven as inverted

# Operation signal to ALU
signal aluOp[4] default 0b0000;          # high bit is MSB

# ROM 4

# Assert to end microcode execution if eq condition is asserted
signal -endIfEq[1] default 1;

# Assert to end microcode execution if eq condition is not asserted
signal -endIfNeq[1] default 1;

# Assert to end microcode execution if carry out condition is asserted
signal -endIfNoCarry[1] default 1;

# Assert to end microcode execution if eq condition is not asserted
# and carry out condition is asserted
signal endIfNeqCarry[1] default 0;

# Assert to end microcode execution if eq condition is not asserted
# and carry out condition is not asserted
signal endIfNeqNoCarry[1] default 0;

# Unconditionally end microcode execution.
# The last microcode word should always assert this signal.
signal -endUncond[1] default 1;

signal rom4Unused[2] default 0b00;

########################################################################
# Patterns: assertions of one or more signals.  These are
# very useful because they can be passed to a template.
########################################################################

# Read signal patterns (most of which require an ALU op)
pattern rd_r0 rdGP=1, rdGPAddr=r0, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_r1 rdGP=1, rdGPAddr=r1, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_r2 rdGP=1, rdGPAddr=r2, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_r3 rdGP=1, rdGPAddr=r3, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_r4 rdGP=1, rdGPAddr=r4, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_r5 rdGP=1, rdGPAddr=r5, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_r6 rdGP=1, rdGPAddr=r6, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_r7 rdGP=1, rdGPAddr=r7, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_ar_lo rdAR=1, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_ar_hi rdAR=1, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_pc_lo rdPC=1, aluMode=1, aluOp=alu_logic_A, aluOut=1;
pattern rd_pc_hi rdPC=1, aluMode=1, aluOp=alu_logic_B, aluOut=1;
pattern rd_mem rwMem=1, memDir=0;

# Write signal patterns
pattern wr_r0 wrGPLo=1, wrGPAddr=r0;
pattern wr_r1 wrGPHi=1, wrGPAddr=r1;
pattern wr_r2 wrGPLo=1, wrGPAddr=r2;
pattern wr_r3 wrGPHi=1, wrGPAddr=r3;
pattern wr_r4 wrGPLo=1, wrGPAddr=r4;
pattern wr_r5 wrGPHi=1, wrGPAddr=r5;
pattern wr_r6 wrGPLo=1, wrGPAddr=r6;
pattern wr_r7 wrGPHi=1, wrGPAddr=r7;
pattern wr_mem rwMem=1, memDir=1;

########################################################################
# Templates: parametized instructions sequences that can
# be spliced into actual instructions as appropriate
########################################################################

# Template for register/register move instructions
template mov(dest_dev, src_dev) {
  start src_dev;
  start dest_dev;
  stop dest_dev;
  stop src_dev, assert -endUncond;
}

########################################################################
# Instructions
#
# Each instruction is a sequence of microcode instruction
# words executed in order.
########################################################################

# nop instruction
ins(0) { assert -endUncond; }

# Move to r0
ins($) { mov(wr_r0, rd_r1); }
ins($) { mov(wr_r0, rd_r2); }
ins($) { mov(wr_r0, rd_r3); }
ins($) { mov(wr_r0, rd_r4); }
ins($) { mov(wr_r0, rd_r5); }
ins($) { mov(wr_r0, rd_r6); }
ins($) { mov(wr_r0, rd_r7); }

# Move to r1
ins($) { mov(wr_r1, rd_r0); }
ins($) { mov(wr_r1, rd_r2); }
ins($) { mov(wr_r1, rd_r3); }
ins($) { mov(wr_r1, rd_r4); }
ins($) { mov(wr_r1, rd_r5); }
ins($) { mov(wr_r1, rd_r6); }
ins($) { mov(wr_r1, rd_r7); }

# Move to r2
ins($) { mov(wr_r2, rd_r0); }
ins($) { mov(wr_r2, rd_r1); }
ins($) { mov(wr_r2, rd_r3); }
ins($) { mov(wr_r2, rd_r4); }
ins($) { mov(wr_r2, rd_r5); }
ins($) { mov(wr_r2, rd_r6); }
ins($) { mov(wr_r2, rd_r7); }

# Move to r3
ins($) { mov(wr_r3, rd_r0); }
ins($) { mov(wr_r3, rd_r1); }
ins($) { mov(wr_r3, rd_r2); }
ins($) { mov(wr_r3, rd_r4); }
ins($) { mov(wr_r3, rd_r5); }
ins($) { mov(wr_r3, rd_r6); }
ins($) { mov(wr_r3, rd_r7); }

# Move to r4
ins($) { mov(wr_r4, rd_r0); }
ins($) { mov(wr_r4, rd_r1); }
ins($) { mov(wr_r4, rd_r2); }
ins($) { mov(wr_r4, rd_r3); }
ins($) { mov(wr_r4, rd_r5); }
ins($) { mov(wr_r4, rd_r6); }
ins($) { mov(wr_r4, rd_r7); }

# Move to r5
ins($) { mov(wr_r5, rd_r0); }
ins($) { mov(wr_r5, rd_r1); }
ins($) { mov(wr_r5, rd_r2); }
ins($) { mov(wr_r5, rd_r3); }
ins($) { mov(wr_r5, rd_r4); }
ins($) { mov(wr_r5, rd_r6); }
ins($) { mov(wr_r5, rd_r7); }

# Move to r6
ins($) { mov(wr_r6, rd_r0); }
ins($) { mov(wr_r6, rd_r1); }
ins($) { mov(wr_r6, rd_r2); }
ins($) { mov(wr_r6, rd_r3); }
ins($) { mov(wr_r6, rd_r4); }
ins($) { mov(wr_r6, rd_r5); }
ins($) { mov(wr_r6, rd_r7); }

# Move to r7
ins($) { mov(wr_r7, rd_r0); }
ins($) { mov(wr_r7, rd_r1); }
ins($) { mov(wr_r7, rd_r2); }
ins($) { mov(wr_r7, rd_r3); }
ins($) { mov(wr_r7, rd_r4); }
ins($) { mov(wr_r7, rd_r5); }
ins($) { mov(wr_r7, rd_r6); }

# special "default" instruction: this sequence of microcode
# instruction words is used for all opcodes that aren't explicitly
# specified
ins(256) { assert -endUncond; }

# vim:ft=ucode:
